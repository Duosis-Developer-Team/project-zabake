---
- name: Reset device processing variables
  set_fact:
    device_result: {}
    current_device_result: {}
    device_info: {}
    zbx_existing_host: {}
    zbx_scenario: "create"
  run_once: false

- name: Create temporary Python script for device processing
  copy:
    content: |
      #!/usr/bin/env python3
      import json
      import sys
      import requests
      
      def check_condition(device, condition_key, condition_value):
          """Check if device matches a condition"""
          if condition_key == 'device_role':
              # Try 'role' first (Netbox API field name), then 'device_role' as fallback
              role_obj = device.get('role') or device.get('device_role')
              role = role_obj.get('name', '') if role_obj and isinstance(role_obj, dict) else ''
              if isinstance(condition_value, list):
                  return role.upper() in [v.upper() for v in condition_value]
              return role.upper() == condition_value.upper()
          
          elif condition_key == 'manufacturer':
              device_type = device.get('device_type') or {}
              manufacturer_obj = device_type.get('manufacturer') or {}
              manufacturer = manufacturer_obj.get('name', '').upper()
              if isinstance(condition_value, list):
                  return manufacturer in [v.upper() for v in condition_value]
              return manufacturer == condition_value.upper()
          
          elif condition_key == 'model_contains':
              device_type = device.get('device_type') or {}
              model = device_type.get('model', '').upper()
              if isinstance(condition_value, list):
                  return any(item.upper() in model for item in condition_value)
              return condition_value.upper() in model
          
          elif condition_key == 'model_suffix':
              device_type = device.get('device_type') or {}
              model = device_type.get('model', '').upper()
              if isinstance(condition_value, list):
                  return any(model.endswith(item.upper()) for item in condition_value)
              return model.endswith(condition_value.upper())
          
          elif condition_key == 'name_contains':
              device_name = device.get('name', '').upper()
              if isinstance(condition_value, list):
                  return any(item.upper() in device_name for item in condition_value)
              return condition_value.upper() in device_name
          
          return False
      
      def determine_device_type(device, device_type_mapping):
          """Determine device type from YAML mapping"""
          mappings = device_type_mapping.get('mappings', [])
          
          # Sort by priority (lower priority number = higher priority)
          sorted_mappings = sorted(mappings, key=lambda x: x.get('priority', 999))
          
          for mapping in sorted_mappings:
              conditions = mapping.get('conditions', {})
              device_type = mapping.get('device_type')
              
              # Check all conditions
              all_match = True
              for condition_key, condition_value in conditions.items():
                  if not check_condition(device, condition_key, condition_value):
                      all_match = False
                      break
              
              if all_match:
                  return device_type
          
          return None
      
      def get_primary_ip(device, netbox_url, netbox_token, verify_ssl):
          primary_ip4 = device.get('primary_ip4')
          if not primary_ip4:
              return None
          
          # If primary_ip4 is a dict/object (expanded in API response)
          if isinstance(primary_ip4, dict):
              address = primary_ip4.get('address', '')
              if address:
                  return address.split('/')[0] if '/' in address else address
              # If address not in dict, try to get from API using ID
              ip_id = primary_ip4.get('id')
              if ip_id:
                  try:
                      response = requests.get(
                          f"{netbox_url.rstrip('/')}/api/ipam/ip-addresses/{ip_id}/",
                          headers={'Authorization': f'Token {netbox_token}', 'Accept': 'application/json'},
                          verify=verify_ssl,
                          timeout=10
                      )
                      if response.status_code == 200:
                          ip_data = response.json()
                          address = ip_data.get('address', '')
                          return address.split('/')[0] if '/' in address else address
                  except:
                      pass
          
          # If primary_ip4 is an integer (ID only)
          if isinstance(primary_ip4, int):
              try:
                  response = requests.get(
                      f"{netbox_url.rstrip('/')}/api/ipam/ip-addresses/{primary_ip4}/",
                      headers={'Authorization': f'Token {netbox_token}', 'Accept': 'application/json'},
                      verify=verify_ssl,
                      timeout=10
                  )
                  if response.status_code == 200:
                      ip_data = response.json()
                      address = ip_data.get('address', '')
                      return address.split('/')[0] if '/' in address else address
              except:
                  pass
          
          # If primary_ip4 is a string (direct address)
          if isinstance(primary_ip4, str):
              return primary_ip4.split('/')[0] if '/' in primary_ip4 else primary_ip4
          
          return None
      
      def get_location_name(device, netbox_url, netbox_token, verify_ssl):
          """Get location name: parent if exists, otherwise location or site"""
          location_obj = device.get('location')
          if not location_obj:
              # No location, fallback to site name
              site = device.get('site') or {}
              if site.get('name'):
                  return site['name']
              return ''
          
          location_id = None
          # If location is expanded as dict
          if isinstance(location_obj, dict):
              location_id = location_obj.get('id')
              # Check if parent is already expanded in the response
              parent = location_obj.get('parent')
              if parent:
                  if isinstance(parent, dict) and parent.get('name'):
                      # Parent is expanded, use it directly
                      return parent.get('name', '')
                  elif isinstance(parent, int):
                      # Parent is just an ID, fetch it directly
                      try:
                          parent_response = requests.get(
                              f"{netbox_url.rstrip('/')}/api/dcim/locations/{parent}/",
                              headers={'Authorization': f'Token {netbox_token}', 'Accept': 'application/json'},
                              verify=verify_ssl,
                              timeout=10
                          )
                          if parent_response.status_code == 200:
                              parent_data = parent_response.json()
                              return parent_data.get('name', '')
                      except Exception as e:
                          pass
          # If location is just an ID
          elif isinstance(location_obj, int):
              location_id = location_obj
          
          # Fetch location from API to get parent information
          if location_id:
              try:
                  # First, fetch the location itself
                  response = requests.get(
                      f"{netbox_url.rstrip('/')}/api/dcim/locations/{location_id}/",
                      headers={'Authorization': f'Token {netbox_token}', 'Accept': 'application/json'},
                      verify=verify_ssl,
                      timeout=10
                  )
                  if response.status_code == 200:
                      loc_data = response.json()
                      # Check for parent in the fetched location data
                      parent = loc_data.get('parent')
                      if parent:
                          # Parent exists, fetch parent's name
                          if isinstance(parent, dict) and parent.get('name'):
                              # Parent is expanded in response
                              return parent.get('name', '')
                          elif isinstance(parent, int):
                              # Parent is just an ID, fetch it
                              try:
                                  parent_response = requests.get(
                                      f"{netbox_url.rstrip('/')}/api/dcim/locations/{parent}/",
                                      headers={'Authorization': f'Token {netbox_token}', 'Accept': 'application/json'},
                                      verify=verify_ssl,
                                      timeout=10
                                  )
                                  if parent_response.status_code == 200:
                                      parent_data = parent_response.json()
                                      return parent_data.get('name', '')
                              except Exception as e:
                                  # If parent fetch fails, fall through to use location name
                                  pass
                      # No parent, use current location name
                      return loc_data.get('name', '')
              except Exception as e:
                  # If location fetch fails, try to use location name from device if available
                  if isinstance(location_obj, dict) and location_obj.get('name'):
                      return location_obj.get('name', '')
          
          # Fallback: if location was a dict with name, use it
          if isinstance(location_obj, dict) and location_obj.get('name'):
              return location_obj.get('name', '')
          
          # Final fallback to site name
          site = device.get('site') or {}
          if site.get('name'):
              return site['name']
          return ''
      
      def extract_host_groups(device, device_type, netbox_url, netbox_token, verify_ssl):
          groups = []
          # 1. Device type (from mapping)
          if device_type:
              groups.append(device_type)
          # 2. Location (parent if exists, otherwise location or site)
          location_name = get_location_name(device, netbox_url, netbox_token, verify_ssl)
          if location_name:
              groups.append(location_name)
          # 3. Contact (Ownership from custom_fields.Sahiplik)
          custom_fields = device.get('custom_fields') or {}
          if custom_fields.get('Sahiplik'):
              groups.append(custom_fields['Sahiplik'])
          return ','.join(groups) if groups else ''
      
      def extract_tags(device):
          tags = {}
          
          # Mevcut tag'ler
          device_type = device.get('device_type') or {}
          manufacturer = device_type.get('manufacturer') or {}
          if manufacturer.get('name'):
              tags['Manufacturer'] = manufacturer['name']
          if device_type.get('model'):
              tags['Device_Type'] = device_type['model']
          elif device_type.get('display'):
              tags['Device_Type'] = device_type['display']
          
          location = device.get('location') or {}
          site = device.get('site') or {}
          if location.get('name'):
              tags['Location_Detail'] = location['name']
          elif site.get('name'):
              tags['Location_Detail'] = site['name']
          if site.get('name'):
              tags['City'] = site['name']
          
          # Tenant (organization/company)
          tenant = device.get('tenant') or {}
          if tenant.get('name'):
              tags['Tenant'] = tenant['name']
          
          # Contact (ownership from custom_fields.Sahiplik)
          custom_fields = device.get('custom_fields') or {}
          if custom_fields.get('Sahiplik'):
              tags['Contact'] = custom_fields['Sahiplik']
          
          if custom_fields.get('Sorumlu_Ekip'):
              tags['Sorumlu_Ekip'] = custom_fields['Sorumlu_Ekip']
          if device.get('id'):
              tags['Loki_ID'] = str(device['id'])
          
          # YENİ TAG'LER - Rack bilgileri
          rack = device.get('rack')
          if rack:
              # Rack dict olarak geliyor veya ID olarak
              if isinstance(rack, dict):
                  if rack.get('name'):
                      tags['Rack_Name'] = rack['name']
                  # Rack type için role kullanılacak (rack_type genellikle null)
                  rack_role = rack.get('role') or {}
                  if rack_role.get('name'):
                      tags['Rack_Type'] = rack_role['name']
          
          # YENİ TAG'LER - Cluster bilgisi
          cluster = device.get('cluster')
          if cluster:
              if isinstance(cluster, dict) and cluster.get('name'):
                  tags['Cluster'] = cluster['name']
          
          # YENİ TAG'LER - Hall bilgisi (location description veya name)
          location = device.get('location')
          if location:
              if isinstance(location, dict):
                  # Description'da "DATA HALL X" formatı var
                  if location.get('description'):
                      tags['Hall'] = location['description']
                  elif location.get('name'):
                      tags['Hall'] = location['name']
          
          # YENİ TAG'LER - Kurulum Tarihi (custom field)
          if custom_fields.get('Kurulum_Tarihi'):
              tags['Kurulum_Tarihi'] = custom_fields['Kurulum_Tarihi']
          
          # Loki tags (device['tags'] array'inden) - ayrı return edilecek
          loki_tags = []
          device_tags = device.get('tags', [])
          for tag in device_tags:
              if isinstance(tag, dict):
                  tag_name = tag.get('name')
                  if tag_name:
                      loki_tags.append(tag_name)
              elif isinstance(tag, str):
                  loki_tags.append(tag)
          
          # None değerleri temizle
          tags = {k: v for k, v in tags.items() if v is not None and v != ''}
          
          return tags, loki_tags  # İki ayrı return: tags dict ve loki_tags list
      
      if __name__ == '__main__':
          device_file = sys.argv[1]
          device_type_mapping_file = sys.argv[2]
          netbox_url = sys.argv[3]
          netbox_token = sys.argv[4]
          verify_ssl = sys.argv[5].lower() == 'true'
          
          # Load device JSON from file
          with open(device_file, 'r') as f:
              device = json.load(f)
          
          # Load device type mapping JSON from file
          with open(device_type_mapping_file, 'r') as f:
              device_type_mapping = json.load(f)
          
          device_type = determine_device_type(device, device_type_mapping)
          location_name = get_location_name(device, netbox_url, netbox_token, verify_ssl)
          tags_dict, loki_tags_list = extract_tags(device)
          
          # Loki tags'i tags dict'ine ekle (her biri ayrı tag olarak)
          for loki_tag in loki_tags_list:
              if loki_tag:
                  # Loki tag'leri "Loki_Tag_" prefix'i ile ekle
                  tags_dict[f'Loki_Tag_{loki_tag}'] = loki_tag
          
          # Get device role
          role_obj = device.get('role') or device.get('device_role')
          device_role = role_obj.get('name', '') if role_obj and isinstance(role_obj, dict) else ''
          
          result = {
              'device_type': device_type,
              'device_role': device_role,
              'primary_ip': get_primary_ip(device, netbox_url, netbox_token, verify_ssl),
              'host_groups': extract_host_groups(device, device_type, netbox_url, netbox_token, verify_ssl),
              'tags': tags_dict,
              'loki_tags': loki_tags_list,
              'location': location_name,
              'dc_id': location_name if location_name else (device.get('site') or {}).get('name', '')
          }
          
          print(json.dumps(result))
    dest: "/tmp/netbox_device_processor.py"
    mode: '0755'
  delegate_to: localhost
  run_once: true

- name: Save device JSON to temporary file
  copy:
    content: "{{ netbox_device | to_json }}"
    dest: "/tmp/netbox_device_{{ netbox_device.id | default('temp') }}.json"
  delegate_to: localhost

- name: Save device type mapping JSON to temporary file
  copy:
    content: "{{ device_type_mapping | to_json }}"
    dest: "/tmp/netbox_device_type_mapping_{{ netbox_device.id | default('temp') }}.json"
  delegate_to: localhost

- name: Process device with Python script
  command: >
    python3 /tmp/netbox_device_processor.py
    "/tmp/netbox_device_{{ netbox_device.id | default('temp') }}.json"
    "/tmp/netbox_device_type_mapping_{{ netbox_device.id | default('temp') }}.json"
    "{{ netbox_url }}"
    "{{ netbox_token }}"
    "{{ netbox_verify_ssl | string }}"
  register: device_processing_result
  changed_when: false
  delegate_to: localhost

- name: Parse device processing result
  set_fact:
    device_info: "{{ device_processing_result.stdout | from_json }}"

- name: Check if host exists in Zabbix by Loki_ID
  set_fact:
    zbx_existing_host: "{{ zabbix_hosts_by_loki_id.get(device_info.tags.Loki_ID | string) }}"
  when: 
    - zabbix_hosts_by_loki_id is defined
    - device_info.tags.Loki_ID is defined
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""
    - zabbix_hosts_by_loki_id.get(device_info.tags.Loki_ID | string) is not none
    - zabbix_hosts_by_loki_id.get(device_info.tags.Loki_ID | string) != None

- name: Fallback to hostname matching if Loki_ID not found
  set_fact:
    zbx_existing_host: "{{ zabbix_hosts_by_hostname.get(netbox_device.name) }}"
  when:
    - zbx_existing_host is not defined or zbx_existing_host == {} or zbx_existing_host.hostid is not defined
    - zabbix_hosts_by_hostname is defined
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""
    - zabbix_hosts_by_hostname.get(netbox_device.name) is not none
    - zabbix_hosts_by_hostname.get(netbox_device.name) != None

- name: Determine scenario (create or update)
  set_fact:
    zbx_scenario: "{{ 'update' if (zbx_existing_host is defined and zbx_existing_host is not none and zbx_existing_host != None and zbx_existing_host.hostid is defined) else 'create' }}"
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""

- name: Display scenario for device
  debug:
    msg: "Device {{ netbox_device.name }}: Scenario = {{ zbx_scenario }} ({{ 'Host exists in Zabbix' if (zbx_existing_host is defined and zbx_existing_host is not none and zbx_existing_host.hostid is defined) else 'New host - will be created' }})"
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""

- name: Record skipped device (no device type)
  set_fact:
    device_result:
      hostname: "{{ netbox_device.name | default('N/A') }}"
      device_role: "{{ device_info.device_role | default('N/A') }}"
      status: "eklenemedi"
      reason: "Device type bulunamadı"
      ip: "{{ device_info.primary_ip | default('N/A') }}"
    current_device_result:
      hostname: "{{ netbox_device.name | default('N/A') }}"
      device_role: "{{ device_info.device_role | default('N/A') }}"
      status: "eklenemedi"
      reason: "Device type bulunamadı"
      ip: "{{ device_info.primary_ip | default('N/A') }}"
  when: device_info.device_type is none or device_info.device_type == ""
  run_once: false

- name: Record skipped device (no IP)
  set_fact:
    device_result:
      hostname: "{{ netbox_device.name | default('N/A') }}"
      device_role: "{{ device_info.device_role | default('N/A') }}"
      status: "eklenemedi"
      reason: "IP adresi bulunamadı"
      ip: "N/A"
    current_device_result:
      hostname: "{{ netbox_device.name | default('N/A') }}"
      device_role: "{{ device_info.device_role | default('N/A') }}"
      status: "eklenemedi"
      reason: "IP adresi bulunamadı"
      ip: "N/A"
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - (device_info.primary_ip is none or device_info.primary_ip == "")
  run_once: false

- name: Skip device if no matching device type
  debug:
    msg: "Skipping device {{ netbox_device.name }} - no matching device type found"
  when: device_info.device_type is none or device_info.device_type == ""
  failed_when: false

- name: Skip device if no IP address
  debug:
    msg: "Skipping device {{ netbox_device.name }} - no primary IP address found"
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - (device_info.primary_ip is none or device_info.primary_ip == "")
  failed_when: false

- name: Create Zabbix record
  set_fact:
    zbx_record:
      DEVICE_TYPE: "{{ device_info.device_type }}"
      DEVICE_ROLE: "{{ device_info.device_role | default('N/A') }}"
      HOST_IP: "{{ device_info.primary_ip }}"
      HOSTNAME: "{{ netbox_device.name }}"
      DC_ID: "{{ device_info.location }}"
      HOST_GROUPS: "{{ device_info.host_groups }}"
      TEMPLATE_TYPE: ""
      MACROS: "{{ device_info.tags | to_json }}"
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""

- name: Zabbix login to obtain auth token
  uri:
    url: "{{ zabbix_url }}"
    method: POST
    body_format: json
    validate_certs: "{{ zabbix_validate_certs }}"
    body:
      jsonrpc: "2.0"
      method: "user.login"
      params:
        username: "{{ zabbix_user }}"
        password: "{{ zabbix_password }}"
      id: 0
  register: zbx_login_resp
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""
  run_once: true
  delegate_to: localhost

- name: Set zabbix_auth from login
  set_fact:
    zabbix_auth: "{{ zbx_login_resp.json.result }}"
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""
    - zbx_login_resp.json.result is defined
  run_once: true
  delegate_to: localhost

- name: Set variables for role
  set_fact:
    _zbx_record_for_role: "{{ zbx_record }}"
    _zabbix_auth_for_role: "{{ zabbix_auth }}"
    _zbx_existing_host_for_role: "{{ zbx_existing_host | default(omit) }}"
    _zbx_scenario_for_role: "{{ zbx_scenario | default('create') }}"
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""
    - zbx_record is defined
    - zabbix_auth is defined

- name: Process device with Zabbix host operations
  include_tasks: zabbix_host_operations.yml
  vars:
    zbx_record: "{{ _zbx_record_for_role }}"
    zabbix_url: "{{ zabbix_url }}"
    zabbix_user: "{{ zabbix_user }}"
    zabbix_password: "{{ zabbix_password }}"
    zabbix_validate_certs: "{{ zabbix_validate_certs }}"
    zabbix_auth: "{{ _zabbix_auth_for_role }}"
    zbx_existing_host: "{{ _zbx_existing_host_for_role }}"
    zbx_scenario: "{{ _zbx_scenario_for_role }}"
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""
    - _zbx_record_for_role is defined
    - _zabbix_auth_for_role is defined

- name: Collect device result from zabbix host operations (if processed)
  set_fact:
    current_device_result: "{{ device_result }}"
  when: 
    - device_result is defined
    - device_result | length > 0
    - device_result.hostname is defined

- name: Debug - Show current device result before save
  debug:
    msg: |
      Device: {{ netbox_device.name | default('Unknown') }}
      Result defined: {{ current_device_result is defined }}
      Result content: {{ current_device_result | default('NOT DEFINED') }}
  when: true

- name: Save device result to temporary file
  copy:
    content: "{{ current_device_result | to_json }}"
    dest: "/tmp/zabbix_host_operation_result_{{ netbox_device.id | default('unknown') }}.json"
  when: 
    - current_device_result is defined
    - current_device_result | length > 0
  delegate_to: localhost
  run_once: false
