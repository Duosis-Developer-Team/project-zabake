---
- name: Reset device processing variables
  set_fact:
    device_result: {}
    current_device_result: {}
    device_info: {}
    zbx_existing_host: {}
    zbx_scenario: "create"
  run_once: false

- name: Create temporary Python script for device processing
  copy:
    content: |
      #!/usr/bin/env python3
      import json
      import sys
      import os
      import requests
      import yaml
      
      # ============= YAML CONFIG LOADING =============
      
      def load_yaml_config(config_path):
          """Load YAML configuration file"""
          try:
              if os.path.exists(config_path):
                  with open(config_path, 'r') as f:
                      return yaml.safe_load(f)
          except Exception as e:
              print(f"Warning: Failed to load config {config_path}: {e}", file=sys.stderr)
          return None
      
      # ============= GENERIC ATTRIBUTE EXTRACTION =============
      
      def extract_by_path(obj, path):
          """
          Extract value from nested object using dot notation path
          Example: extract_by_path(device, "device_type.manufacturer.name")
          Returns None if path doesn't exist
          """
          if not obj or not path:
              return None
          
          keys = path.split('.')
          current = obj
          
          for key in keys:
              if current is None:
                  return None
              if isinstance(current, dict):
                  current = current.get(key)
              else:
                  return None
          
          return current
      
      def extract_by_path_with_fallback(obj, path, fallback_paths=None):
          """
          Extract value with fallback paths
          Returns first non-None value found
          """
          # Try primary path
          value = extract_by_path(obj, path)
          if value is not None and value != '':
              return value
          
          # Try fallback paths
          if fallback_paths:
              if isinstance(fallback_paths, str):
                  fallback_paths = [fallback_paths]
              for fallback_path in fallback_paths:
                  value = extract_by_path(obj, fallback_path)
                  if value is not None and value != '':
                      return value
          
          return None
      
      # ============= ORIGINAL FUNCTIONS (PRESERVED) =============
      
      def check_condition(device, condition_key, condition_value):
          """Check if device matches a condition"""
          if condition_key == 'device_role':
              # Try 'role' first (Netbox API field name), then 'device_role' as fallback
              role_obj = device.get('role') or device.get('device_role')
              role = role_obj.get('name', '') if role_obj and isinstance(role_obj, dict) else ''
              if isinstance(condition_value, list):
                  return role.upper() in [v.upper() for v in condition_value]
              return role.upper() == condition_value.upper()
          
          elif condition_key == 'manufacturer':
              device_type = device.get('device_type') or {}
              manufacturer_obj = device_type.get('manufacturer') or {}
              manufacturer = manufacturer_obj.get('name', '').upper()
              if isinstance(condition_value, list):
                  return manufacturer in [v.upper() for v in condition_value]
              return manufacturer == condition_value.upper()
          
          elif condition_key == 'model_contains':
              device_type = device.get('device_type') or {}
              model = device_type.get('model', '').upper()
              if isinstance(condition_value, list):
                  return any(item.upper() in model for item in condition_value)
              return condition_value.upper() in model
          
          elif condition_key == 'model_suffix':
              device_type = device.get('device_type') or {}
              model = device_type.get('model', '').upper()
              if isinstance(condition_value, list):
                  return any(model.endswith(item.upper()) for item in condition_value)
              return model.endswith(condition_value.upper())
          
          elif condition_key == 'name_contains':
              device_name = device.get('name', '').upper()
              if isinstance(condition_value, list):
                  return any(item.upper() in device_name for item in condition_value)
              return condition_value.upper() in device_name
          
          return False
      
      def determine_device_type(device, device_type_mapping):
          """Determine device type from YAML mapping"""
          mappings = device_type_mapping.get('mappings', [])
          
          # Sort by priority (lower priority number = higher priority)
          sorted_mappings = sorted(mappings, key=lambda x: x.get('priority', 999))
          
          for mapping in sorted_mappings:
              conditions = mapping.get('conditions', {})
              device_type = mapping.get('device_type')
              
              # Check all conditions
              all_match = True
              for condition_key, condition_value in conditions.items():
                  if not check_condition(device, condition_key, condition_value):
                      all_match = False
                      break
              
              if all_match:
                  return device_type
          
          return None
      
      def get_primary_ip(device, netbox_url, netbox_token, verify_ssl):
          primary_ip4 = device.get('primary_ip4')
          if not primary_ip4:
              return None
          
          # If primary_ip4 is a dict/object (expanded in API response)
          if isinstance(primary_ip4, dict):
              address = primary_ip4.get('address', '')
              if address:
                  return address.split('/')[0] if '/' in address else address
              # If address not in dict, try to get from API using ID
              ip_id = primary_ip4.get('id')
              if ip_id:
                  try:
                      response = requests.get(
                          f"{netbox_url.rstrip('/')}/api/ipam/ip-addresses/{ip_id}/",
                          headers={'Authorization': f'Token {netbox_token}', 'Accept': 'application/json'},
                          verify=verify_ssl,
                          timeout=10
                      )
                      if response.status_code == 200:
                          ip_data = response.json()
                          address = ip_data.get('address', '')
                          return address.split('/')[0] if '/' in address else address
                  except:
                      pass
          
          # If primary_ip4 is an integer (ID only)
          if isinstance(primary_ip4, int):
              try:
                  response = requests.get(
                      f"{netbox_url.rstrip('/')}/api/ipam/ip-addresses/{primary_ip4}/",
                      headers={'Authorization': f'Token {netbox_token}', 'Accept': 'application/json'},
                      verify=verify_ssl,
                      timeout=10
                  )
                  if response.status_code == 200:
                      ip_data = response.json()
                      address = ip_data.get('address', '')
                      return address.split('/')[0] if '/' in address else address
              except:
                  pass
          
          # If primary_ip4 is a string (direct address)
          if isinstance(primary_ip4, str):
              return primary_ip4.split('/')[0] if '/' in primary_ip4 else primary_ip4
          
          return None
      
      def get_location_name(device, netbox_url, netbox_token, verify_ssl):
          """Get location name: parent if exists, otherwise location or site"""
          location_obj = device.get('location')
          if not location_obj:
              # No location, fallback to site name
              site = device.get('site') or {}
              if site.get('name'):
                  return site['name']
              return ''
          
          location_id = None
          # If location is expanded as dict
          if isinstance(location_obj, dict):
              location_id = location_obj.get('id')
              # Check if parent is already expanded in the response
              parent = location_obj.get('parent')
              if parent:
                  if isinstance(parent, dict) and parent.get('name'):
                      # Parent is expanded, use it directly
                      return parent.get('name', '')
                  elif isinstance(parent, int):
                      # Parent is just an ID, fetch it directly
                      try:
                          parent_response = requests.get(
                              f"{netbox_url.rstrip('/')}/api/dcim/locations/{parent}/",
                              headers={'Authorization': f'Token {netbox_token}', 'Accept': 'application/json'},
                              verify=verify_ssl,
                              timeout=10
                          )
                          if parent_response.status_code == 200:
                              parent_data = parent_response.json()
                              return parent_data.get('name', '')
                      except Exception as e:
                          pass
          # If location is just an ID
          elif isinstance(location_obj, int):
              location_id = location_obj
          
          # Fetch location from API to get parent information
          if location_id:
              try:
                  # First, fetch the location itself
                  response = requests.get(
                      f"{netbox_url.rstrip('/')}/api/dcim/locations/{location_id}/",
                      headers={'Authorization': f'Token {netbox_token}', 'Accept': 'application/json'},
                      verify=verify_ssl,
                      timeout=10
                  )
                  if response.status_code == 200:
                      loc_data = response.json()
                      # Check for parent in the fetched location data
                      parent = loc_data.get('parent')
                      if parent:
                          # Parent exists, fetch parent's name
                          if isinstance(parent, dict) and parent.get('name'):
                              # Parent is expanded in response
                              return parent.get('name', '')
                          elif isinstance(parent, int):
                              # Parent is just an ID, fetch it
                              try:
                                  parent_response = requests.get(
                                      f"{netbox_url.rstrip('/')}/api/dcim/locations/{parent}/",
                                      headers={'Authorization': f'Token {netbox_token}', 'Accept': 'application/json'},
                                      verify=verify_ssl,
                                      timeout=10
                                  )
                                  if parent_response.status_code == 200:
                                      parent_data = parent_response.json()
                                      return parent_data.get('name', '')
                              except Exception as e:
                                  # If parent fetch fails, fall through to use location name
                                  pass
                      # No parent, use current location name
                      return loc_data.get('name', '')
              except Exception as e:
                  # If location fetch fails, try to use location name from device if available
                  if isinstance(location_obj, dict) and location_obj.get('name'):
                      return location_obj.get('name', '')
          
          # Fallback: if location was a dict with name, use it
          if isinstance(location_obj, dict) and location_obj.get('name'):
              return location_obj.get('name', '')
          
          # Final fallback to site name
          site = device.get('site') or {}
          if site.get('name'):
              return site['name']
          return ''
      
      def extract_host_groups_from_config(device, config, device_type, templates, netbox_url, netbox_token, verify_ssl):
          """
          Extract host groups using YAML configuration
          Falls back to hardcoded logic if config is None
          """
          groups = []
          
          if config is None:
              # FALLBACK: Use original hardcoded logic
              if device_type:
                  groups.append(device_type)
              location_name = get_location_name(device, netbox_url, netbox_token, verify_ssl)
              if location_name:
                  groups.append(location_name)
              custom_fields = device.get('custom_fields') or {}
              if custom_fields.get('Sahiplik'):
                  groups.append(custom_fields['Sahiplik'])
              return ','.join(groups) if groups else ''
          
          # CONFIG-DRIVEN LOGIC
          sources = config.get('host_groups', {}).get('sources', [])
          settings = config.get('host_groups', {}).get('settings', {})
          
          # Sort sources by priority
          sorted_sources = sorted(sources, key=lambda x: x.get('priority', 999))
          
          for source in sorted_sources:
              if not source.get('enabled', True):
                  continue
              
              source_type = source.get('type')
              value = None
              
              if source_type == 'mapping_result':
                  # Device type from mapping result
                  value = device_type
              
              elif source_type == 'netbox_attribute':
                  # Extract from Netbox attribute path
                  path = source.get('path')
                  fallback = source.get('fallback')
                  value = extract_by_path_with_fallback(device, path, fallback)
              
              elif source_type == 'custom_field':
                  # Extract from custom field
                  field_name = source.get('field_name')
                  custom_fields = device.get('custom_fields') or {}
                  value = custom_fields.get(field_name)
              
              elif source_type == 'computed':
                  # Use computed function
                  compute_func = source.get('compute_function')
                  if compute_func == 'get_location_name':
                      value = get_location_name(device, netbox_url, netbox_token, verify_ssl)
              
              elif source_type == 'template_mapping':
                  # Extract from template mappings
                  attr = source.get('attribute', 'host_groups')
                  template_groups = []
                  for template in templates:
                      if attr in template:
                          template_groups.extend(template.get(attr, []))
                  if template_groups:
                      groups.extend(template_groups)
                      continue
              
              # Add value if not empty
              if value and value != '':
                  if settings.get('trim', True) and isinstance(value, str):
                      value = value.strip()
                  groups.append(value)
          
          # Apply global settings
          if settings.get('unique', True):
              # Preserve order while removing duplicates
              seen = set()
              unique_groups = []
              for g in groups:
                  if g not in seen:
                      seen.add(g)
                      unique_groups.append(g)
              groups = unique_groups
          
          if settings.get('skip_empty', True):
              groups = [g for g in groups if g and g != '']
          
          separator = settings.get('separator', ',')
          return separator.join(groups) if groups else ''
      
      # Keep original function for backward compatibility
      def extract_host_groups(device, device_type, netbox_url, netbox_token, verify_ssl):
          """Original hardcoded host groups extraction (deprecated, use extract_host_groups_from_config)"""
          groups = []
          # 1. Device type (from mapping)
          if device_type:
              groups.append(device_type)
          # 2. Location (parent if exists, otherwise location or site)
          location_name = get_location_name(device, netbox_url, netbox_token, verify_ssl)
          if location_name:
              groups.append(location_name)
          # 3. Contact (Ownership from custom_fields.Sahiplik)
          custom_fields = device.get('custom_fields') or {}
          if custom_fields.get('Sahiplik'):
              groups.append(custom_fields['Sahiplik'])
          return ','.join(groups) if groups else ''
      
      def extract_hall(device):
          """Computed function to extract Hall information"""
          location = device.get('location')
          if location and isinstance(location, dict):
              # Try description first (e.g., "DATA HALL X")
              if location.get('description'):
                  return location['description']
              elif location.get('name'):
                  return location['name']
          return None
      
      def extract_tags_from_config(device, config, device_type=None, templates=None):
          """
          Extract tags using YAML configuration
          Falls back to hardcoded logic if config is None
          
          Args:
              device: Netbox device data
              config: Tags configuration from YAML
              device_type: Device type from mapping (optional, for mapping_result source)
              templates: Templates list (optional, for template_mapping source)
          """
          tags = {}
          loki_tags = []
          
          if config is None:
              # FALLBACK: Use original hardcoded logic
              return extract_tags_original(device)
          
          # CONFIG-DRIVEN LOGIC
          definitions = config.get('tags', {}).get('definitions', [])
          settings = config.get('tags', {}).get('settings', {})
          
          for tag_def in definitions:
              if not tag_def.get('enabled', True):
                  continue
              
              tag_name = tag_def.get('tag_name')
              source_type = tag_def.get('source_type')
              value = None
              
              if source_type == 'netbox_attribute':
                  # Extract from Netbox attribute path
                  path = tag_def.get('path')
                  fallback = tag_def.get('fallback')
                  value = extract_by_path_with_fallback(device, path, fallback)
                  
                  # Apply transform if specified
                  transform = tag_def.get('transform')
                  if transform == 'to_string' and value is not None:
                      value = str(value)
              
              elif source_type == 'custom_field':
                  # Extract from custom field
                  field_name = tag_def.get('field_name')
                  custom_fields = device.get('custom_fields') or {}
                  value = custom_fields.get(field_name)
              
              elif source_type == 'computed':
                  # Use computed function
                  compute_func = tag_def.get('compute_function')
                  if compute_func == 'extract_hall':
                      value = extract_hall(device)
              
              elif source_type == 'mapping_result':
                  # Device type from mapping result
                  value = device_type
              
              elif source_type == 'template_mapping':
                  # Extract host groups from template mappings as tags
                  # This creates multiple tags if multiple template groups exist
                  if templates:
                      attr = tag_def.get('attribute', 'host_groups')
                      template_groups = []
                      for template in templates:
                          if attr in template:
                              template_groups.extend(template.get(attr, []))
                      
                      # Join with separator or create individual tags
                      if template_groups:
                          separator = tag_def.get('separator', ',')
                          value = separator.join(template_groups)
              
              elif source_type == 'array_expansion':
                  # Expand array into multiple tags with prefix
                  path = tag_def.get('path')
                  prefix = tag_def.get('prefix', '')
                  array_data = extract_by_path(device, path)
                  
                  if array_data and isinstance(array_data, list):
                      for item in array_data:
                          item_name = None
                          if isinstance(item, dict):
                              item_name = item.get('name')
                          elif isinstance(item, str):
                              item_name = item
                          
                          if item_name:
                              loki_tags.append(item_name)
                              # Add as separate tag with prefix
                              tags[f'{prefix}{item_name}'] = item_name
                  continue  # Skip normal tag addition
              
              # Add tag if value is not empty
              if value is not None and value != '':
                  if settings.get('trim', True) and isinstance(value, str):
                      value = value.strip()
                  
                  # Skip if treat_empty_as_none and value is empty string
                  if settings.get('treat_empty_as_none', True) and value == '':
                      continue
                  
                  tags[tag_name] = value
          
          # Apply global settings
          if settings.get('skip_none', True):
              tags = {k: v for k, v in tags.items() if v is not None}
          
          if settings.get('skip_empty', True):
              tags = {k: v for k, v in tags.items() if v != ''}
          
          return tags, loki_tags
      
      # Keep original function for backward compatibility
      def extract_tags_original(device):
          """Original hardcoded tags extraction (deprecated, use extract_tags_from_config)"""
          tags = {}
          
          # Mevcut tag'ler
          device_type = device.get('device_type') or {}
          manufacturer = device_type.get('manufacturer') or {}
          if manufacturer.get('name'):
              tags['Manufacturer'] = manufacturer['name']
          if device_type.get('model'):
              tags['Device_Type'] = device_type['model']
          elif device_type.get('display'):
              tags['Device_Type'] = device_type['display']
          
          location = device.get('location') or {}
          site = device.get('site') or {}
          if location.get('name'):
              tags['Location_Detail'] = location['name']
          elif site.get('name'):
              tags['Location_Detail'] = site['name']
          if site.get('name'):
              tags['City'] = site['name']
          
          # Tenant (organization/company)
          tenant = device.get('tenant') or {}
          if tenant.get('name'):
              tags['Tenant'] = tenant['name']
          
          # Contact (ownership from custom_fields.Sahiplik)
          custom_fields = device.get('custom_fields') or {}
          if custom_fields.get('Sahiplik'):
              tags['Contact'] = custom_fields['Sahiplik']
          
          if custom_fields.get('Sorumlu_Ekip'):
              tags['Sorumlu_Ekip'] = custom_fields['Sorumlu_Ekip']
          if device.get('id'):
              tags['Loki_ID'] = str(device['id'])
          
          # YENİ TAG'LER - Rack bilgileri
          rack = device.get('rack')
          if rack:
              # Rack dict olarak geliyor veya ID olarak
              if isinstance(rack, dict):
                  if rack.get('name'):
                      tags['Rack_Name'] = rack['name']
                  # Rack type için role kullanılacak (rack_type genellikle null)
                  rack_role = rack.get('role') or {}
                  if rack_role.get('name'):
                      tags['Rack_Type'] = rack_role['name']
          
          # YENİ TAG'LER - Cluster bilgisi
          cluster = device.get('cluster')
          if cluster:
              if isinstance(cluster, dict) and cluster.get('name'):
                  tags['Cluster'] = cluster['name']
          
          # YENİ TAG'LER - Hall bilgisi (location description veya name)
          location = device.get('location')
          if location:
              if isinstance(location, dict):
                  # Description'da "DATA HALL X" formatı var
                  if location.get('description'):
                      tags['Hall'] = location['description']
                  elif location.get('name'):
                      tags['Hall'] = location['name']
          
          # YENİ TAG'LER - Kurulum Tarihi (custom field)
          if custom_fields.get('Kurulum_Tarihi'):
              tags['Kurulum_Tarihi'] = custom_fields['Kurulum_Tarihi']
          
          # Loki tags (device['tags'] array'inden) - ayrı return edilecek
          loki_tags = []
          device_tags = device.get('tags', [])
          for tag in device_tags:
              if isinstance(tag, dict):
                  tag_name = tag.get('name')
                  if tag_name:
                      loki_tags.append(tag_name)
              elif isinstance(tag, str):
                  loki_tags.append(tag)
          
          # None değerleri temizle
          tags = {k: v for k, v in tags.items() if v is not None and v != ''}
          
          return tags, loki_tags  # İki ayrı return: tags dict ve loki_tags list
      
      def extract_tags(device):
          """Wrapper for backward compatibility"""
          return extract_tags_original(device)
      
      if __name__ == '__main__':
          device_file = sys.argv[1]
          device_type_mapping_file = sys.argv[2]
          netbox_url = sys.argv[3]
          netbox_token = sys.argv[4]
          verify_ssl = sys.argv[5].lower() == 'true'
          host_groups_config_file = sys.argv[6] if len(sys.argv) > 6 else None
          tags_config_file = sys.argv[7] if len(sys.argv) > 7 else None
          templates_file = sys.argv[8] if len(sys.argv) > 8 else None
          
          # Load device JSON from file
          with open(device_file, 'r') as f:
              device = json.load(f)
          
          # Load device type mapping JSON from file
          with open(device_type_mapping_file, 'r') as f:
              device_type_mapping = json.load(f)
          
          # Load YAML configs (optional)
          host_groups_config = None
          tags_config = None
          templates = []
          
          if host_groups_config_file:
              host_groups_config = load_yaml_config(host_groups_config_file)
          
          if tags_config_file:
              tags_config = load_yaml_config(tags_config_file)
          
          if templates_file:
              templates_data = load_yaml_config(templates_file)
              if templates_data:
                  # templates.yml format: device_type -> list of templates
                  # We need to convert this for the specific device_type
                  device_type_temp = determine_device_type(device, device_type_mapping)
                  if device_type_temp and device_type_temp in templates_data:
                      templates = templates_data[device_type_temp]
          
          # Determine device type
          device_type = determine_device_type(device, device_type_mapping)
          location_name = get_location_name(device, netbox_url, netbox_token, verify_ssl)
          
          # Extract host groups using config or fallback
          host_groups_str = extract_host_groups_from_config(
              device, host_groups_config, device_type, templates, 
              netbox_url, netbox_token, verify_ssl
          )
          
          # Extract tags using config or fallback
          tags_dict, loki_tags_list = extract_tags_from_config(device, tags_config, device_type, templates)
          
          # If using fallback (no config), manually add Loki tags with prefix
          # (Config-driven mode handles this automatically via array_expansion)
          if tags_config is None:
              for loki_tag in loki_tags_list:
                  if loki_tag:
                      # Loki tag'leri "Loki_Tag_" prefix'i ile ekle
                      tags_dict[f'Loki_Tag_{loki_tag}'] = loki_tag
          
          # Get device role
          role_obj = device.get('role') or device.get('device_role')
          device_role = role_obj.get('name', '') if role_obj and isinstance(role_obj, dict) else ''
          
          result = {
              'device_type': device_type,
              'device_role': device_role,
              'primary_ip': get_primary_ip(device, netbox_url, netbox_token, verify_ssl),
              'host_groups': host_groups_str,
              'tags': tags_dict,
              'loki_tags': loki_tags_list,
              'location': location_name,
              'dc_id': location_name if location_name else (device.get('site') or {}).get('name', '')
          }
          
          print(json.dumps(result))
    dest: "/tmp/netbox_device_processor.py"
    mode: '0755'
  delegate_to: localhost
  run_once: true

- name: Save device JSON to temporary file
  copy:
    content: "{{ netbox_device | to_json }}"
    dest: "/tmp/netbox_device_{{ netbox_device.id | default('temp') }}.json"
  delegate_to: localhost

- name: Save device type mapping JSON to temporary file
  copy:
    content: "{{ device_type_mapping | to_json }}"
    dest: "/tmp/netbox_device_type_mapping_{{ netbox_device.id | default('temp') }}.json"
  delegate_to: localhost

- name: Check if host_groups_config exists
  stat:
    path: "{{ host_groups_config_path | default((playbook_dir | default(ansible_playbook_directory)) + '/../mappings/host_groups_config.yml') }}"
  register: host_groups_config_stat
  delegate_to: localhost
  run_once: true

- name: Check if tags_config exists
  stat:
    path: "{{ tags_config_path | default((playbook_dir | default(ansible_playbook_directory)) + '/../mappings/tags_config.yml') }}"
  register: tags_config_stat
  delegate_to: localhost
  run_once: true

- name: Check if templates file exists
  stat:
    path: "{{ templates_map_path | default((playbook_dir | default(ansible_playbook_directory)) + '/../mappings/templates.yml') }}"
  register: templates_stat
  delegate_to: localhost
  run_once: true

- name: Process device with Python script
  command: >
    python3 /tmp/netbox_device_processor.py
    "/tmp/netbox_device_{{ netbox_device.id | default('temp') }}.json"
    "/tmp/netbox_device_type_mapping_{{ netbox_device.id | default('temp') }}.json"
    "{{ netbox_url }}"
    "{{ netbox_token }}"
    "{{ netbox_verify_ssl | string }}"
    "{{ host_groups_config_path | default((playbook_dir | default(ansible_playbook_directory)) + '/../mappings/host_groups_config.yml') if host_groups_config_stat.stat.exists else '' }}"
    "{{ tags_config_path | default((playbook_dir | default(ansible_playbook_directory)) + '/../mappings/tags_config.yml') if tags_config_stat.stat.exists else '' }}"
    "{{ templates_map_path | default((playbook_dir | default(ansible_playbook_directory)) + '/../mappings/templates.yml') if templates_stat.stat.exists else '' }}"
  register: device_processing_result
  changed_when: false
  delegate_to: localhost

- name: Parse device processing result
  set_fact:
    device_info: "{{ device_processing_result.stdout | from_json }}"

- name: Check if host exists in Zabbix by Loki_ID
  set_fact:
    zbx_existing_host: "{{ zabbix_hosts_by_loki_id.get(device_info.tags.Loki_ID | string) }}"
  when: 
    - zabbix_hosts_by_loki_id is defined
    - device_info.tags.Loki_ID is defined
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""
    - zabbix_hosts_by_loki_id.get(device_info.tags.Loki_ID | string) is not none
    - zabbix_hosts_by_loki_id.get(device_info.tags.Loki_ID | string) != None

- name: Fallback to hostname matching if Loki_ID not found
  set_fact:
    zbx_existing_host: "{{ zabbix_hosts_by_hostname.get(netbox_device.name) }}"
  when:
    - zbx_existing_host is not defined or zbx_existing_host == {} or zbx_existing_host.hostid is not defined
    - zabbix_hosts_by_hostname is defined
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""
    - zabbix_hosts_by_hostname.get(netbox_device.name) is not none
    - zabbix_hosts_by_hostname.get(netbox_device.name) != None

- name: Determine scenario (create or update)
  set_fact:
    zbx_scenario: "{{ 'update' if (zbx_existing_host is defined and zbx_existing_host is not none and zbx_existing_host != None and zbx_existing_host.hostid is defined) else 'create' }}"
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""

- name: Display scenario for device
  debug:
    msg: "Device {{ netbox_device.name }}: Scenario = {{ zbx_scenario }} ({{ 'Host exists in Zabbix' if (zbx_existing_host is defined and zbx_existing_host is not none and zbx_existing_host.hostid is defined) else 'New host - will be created' }})"
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""

- name: Record skipped device (no device type)
  set_fact:
    device_result:
      hostname: "{{ netbox_device.name | default('N/A') }}"
      device_role: "{{ device_info.device_role | default('N/A') }}"
      status: "eklenemedi"
      reason: "Device type bulunamadı"
      ip: "{{ device_info.primary_ip | default('N/A') }}"
    current_device_result:
      hostname: "{{ netbox_device.name | default('N/A') }}"
      device_role: "{{ device_info.device_role | default('N/A') }}"
      status: "eklenemedi"
      reason: "Device type bulunamadı"
      ip: "{{ device_info.primary_ip | default('N/A') }}"
  when: device_info.device_type is none or device_info.device_type == ""
  run_once: false

- name: Record skipped device (no IP)
  set_fact:
    device_result:
      hostname: "{{ netbox_device.name | default('N/A') }}"
      device_role: "{{ device_info.device_role | default('N/A') }}"
      status: "eklenemedi"
      reason: "IP adresi bulunamadı"
      ip: "N/A"
    current_device_result:
      hostname: "{{ netbox_device.name | default('N/A') }}"
      device_role: "{{ device_info.device_role | default('N/A') }}"
      status: "eklenemedi"
      reason: "IP adresi bulunamadı"
      ip: "N/A"
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - (device_info.primary_ip is none or device_info.primary_ip == "")
  run_once: false

- name: Skip device if no matching device type
  debug:
    msg: "Skipping device {{ netbox_device.name }} - no matching device type found"
  when: device_info.device_type is none or device_info.device_type == ""
  failed_when: false

- name: Skip device if no IP address
  debug:
    msg: "Skipping device {{ netbox_device.name }} - no primary IP address found"
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - (device_info.primary_ip is none or device_info.primary_ip == "")
  failed_when: false

- name: Create Zabbix record
  set_fact:
    zbx_record:
      DEVICE_TYPE: "{{ device_info.device_type }}"
      DEVICE_ROLE: "{{ device_info.device_role | default('N/A') }}"
      HOST_IP: "{{ device_info.primary_ip }}"
      HOSTNAME: "{{ netbox_device.name }}"
      DC_ID: "{{ device_info.location }}"
      HOST_GROUPS: "{{ device_info.host_groups }}"
      TEMPLATE_TYPE: ""
      MACROS: "{{ device_info.tags | to_json }}"
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""

- name: Zabbix login to obtain auth token
  uri:
    url: "{{ zabbix_url }}"
    method: POST
    body_format: json
    validate_certs: "{{ zabbix_validate_certs }}"
    body:
      jsonrpc: "2.0"
      method: "user.login"
      params:
        username: "{{ zabbix_user }}"
        password: "{{ zabbix_password }}"
      id: 0
  register: zbx_login_resp
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""
  run_once: true
  delegate_to: localhost

- name: Set zabbix_auth from login
  set_fact:
    zabbix_auth: "{{ zbx_login_resp.json.result }}"
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""
    - zbx_login_resp.json.result is defined
  run_once: true
  delegate_to: localhost

- name: Set variables for role
  set_fact:
    _zbx_record_for_role: "{{ zbx_record }}"
    _zabbix_auth_for_role: "{{ zabbix_auth }}"
    _zbx_existing_host_for_role: "{{ zbx_existing_host | default(omit) }}"
    _zbx_scenario_for_role: "{{ zbx_scenario | default('create') }}"
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""
    - zbx_record is defined
    - zabbix_auth is defined

- name: Process device with Zabbix host operations
  include_tasks: zabbix_host_operations.yml
  vars:
    zbx_record: "{{ _zbx_record_for_role }}"
    zabbix_url: "{{ zabbix_url }}"
    zabbix_user: "{{ zabbix_user }}"
    zabbix_password: "{{ zabbix_password }}"
    zabbix_validate_certs: "{{ zabbix_validate_certs }}"
    zabbix_auth: "{{ _zabbix_auth_for_role }}"
    zbx_existing_host: "{{ _zbx_existing_host_for_role }}"
    zbx_scenario: "{{ _zbx_scenario_for_role }}"
  when: 
    - device_info.device_type is not none
    - device_info.device_type != ""
    - device_info.primary_ip is not none
    - device_info.primary_ip != ""
    - _zbx_record_for_role is defined
    - _zabbix_auth_for_role is defined

- name: Collect device result from zabbix host operations (if processed)
  set_fact:
    current_device_result: "{{ device_result }}"
  when: 
    - device_result is defined
    - device_result | length > 0
    - device_result.hostname is defined

- name: Debug - Show current device result before save
  debug:
    msg: |
      Device: {{ netbox_device.name | default('Unknown') }}
      Result defined: {{ current_device_result is defined }}
      Result content: {{ current_device_result | default('NOT DEFINED') }}
  when: true

- name: Save device result to temporary file
  copy:
    content: "{{ current_device_result | to_json }}"
    dest: "/tmp/zabbix_host_operation_result_{{ netbox_device.id | default('unknown') }}.json"
  when: 
    - current_device_result is defined
    - current_device_result | length > 0
  delegate_to: localhost
  run_once: false
