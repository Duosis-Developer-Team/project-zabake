---
- name: Resolve CSV absolute path
  set_fact:
    zbx_csv_path_resolved: "{{ (zbx_migration_csv if zbx_migration_csv.startswith('/') else (playbook_dir | default(ansible_playbook_directory) + '/' + zbx_migration_csv)) }}"

- name: Stat CSV on controller
  stat:
    path: "{{ zbx_csv_path_resolved }}"
  register: zbx_csv_ctrl_stat
  delegate_to: localhost
  run_once: true

- name: Slurp CSV from controller when exists
  when: zbx_csv_ctrl_stat.stat.exists
  slurp:
    path: "{{ zbx_csv_path_resolved }}"
  register: zbx_csv_slurp_ctrl
  delegate_to: localhost
  run_once: true

- name: Set CSV lines from controller
  when: zbx_csv_ctrl_stat.stat.exists
  set_fact:
    zbx_csv_lines: "{{ (zbx_csv_slurp_ctrl.content | b64decode).splitlines() }}"

- name: Slurp CSV from remote host when not on controller
  when: not zbx_csv_ctrl_stat.stat.exists
  slurp:
    path: "{{ zbx_csv_path_resolved }}"
  register: zbx_csv_slurp_remote

- name: Set CSV lines from remote
  when: not zbx_csv_ctrl_stat.stat.exists
  set_fact:
    zbx_csv_lines: "{{ (zbx_csv_slurp_remote.content | b64decode).splitlines() }}"

- name: Create temporary CSV file for parsing
  copy:
    content: "{{ zbx_csv_lines | join('\n') }}"
    dest: "/tmp/zabbix_csv_import.csv"
  register: zbx_csv_temp_file
  delegate_to: localhost
  run_once: true

- name: Create temporary Python script for CSV parsing
  copy:
    content: |
      import csv
      import json
      import sys
      
      records = []
      csv_file = sys.argv[1]
      try:
          with open(csv_file, 'r', encoding='utf-8') as f:
              reader = csv.DictReader(f)
              for row in reader:
                  cleaned_row = {}
                  for k, v in row.items():
                      if v:
                          v = v.strip()
                          # Remove surrounding quotes if present
                          if len(v) >= 2 and v[0] == '"' and v[-1] == '"':
                              v = v[1:-1]
                      cleaned_row[k.strip()] = v if v else ''
                  records.append(cleaned_row)
      except Exception as e:
          print(json.dumps({'error': str(e)}), file=sys.stderr)
          sys.exit(1)
      
      print(json.dumps(records))
    dest: "/tmp/zabbix_csv_import_parser.py"
    mode: '0755'
  register: zbx_python_script
  delegate_to: localhost
  run_once: true

- name: Parse CSV using Python script
  command: "python3 {{ zbx_python_script.dest }} {{ zbx_csv_temp_file.dest }}"
  args:
    creates: "{{ zbx_csv_temp_file.dest }}"
  register: zbx_csv_parse_result
  changed_when: false
  delegate_to: localhost
  run_once: true

- name: Remove temporary files
  file:
    path: "{{ item }}"
    state: absent
  loop:
    - "{{ zbx_csv_temp_file.dest }}"
    - "{{ zbx_python_script.dest }}"
  delegate_to: localhost
  run_once: true

- name: Set parsed CSV records
  set_fact:
    zbx_records: "{{ zbx_csv_parse_result.stdout | from_json }}"

- name: Zabbix login to obtain auth token (if not provided)
  when: zabbix_auth | length == 0
  uri:
    url: "{{ zabbix_url }}"
    method: POST
    body_format: json
    validate_certs: "{{ zabbix_validate_certs }}"
    body:
      jsonrpc: "2.0"
      method: "user.login"
      params:
        username: "{{ zabbix_user }}"
        password: "{{ zabbix_password }}"
      id: 0
  register: zbx_login_resp

- name: Set zabbix_auth from login
  when: zabbix_auth | length == 0
  set_fact:
    zabbix_auth: "{{ zbx_login_resp.json.result }}"

- name: Collect all required host groups from CSV
  vars:
    _csv_groups_raw: >-
      {{ zbx_records | selectattr('HOST_GROUPS', 'defined') | map(attribute='HOST_GROUPS') | list }}
    _csv_groups_split: >-
      {{ _csv_groups_raw | map('split', ',') | flatten | map('trim') | reject('equalto', '') | list }}
    _device_groups: >-
      {{ zbx_records | map(attribute='DEVICE_TYPE') | list }}
  set_fact:
    zbx_required_groups: "{{ (_csv_groups_split + _device_groups) | unique }}"

- name: Get existing host groups
  uri:
    url: "{{ zabbix_url }}"
    method: POST
    body_format: json
    validate_certs: "{{ zabbix_validate_certs }}"
    body:
      jsonrpc: "2.0"
      method: "hostgroup.get"
      params:
        output: ["groupid", "name"]
        filter:
          name: "{{ zbx_required_groups }}"
      auth: "{{ zabbix_auth }}"
      id: 101
  register: zbx_existing_groups_resp

- name: Identify missing groups
  vars:
    _existing_names: "{{ zbx_existing_groups_resp.json.result | map(attribute='name') | list }}"
  set_fact:
    zbx_missing_groups: "{{ zbx_required_groups | difference(_existing_names) }}"

- name: Create missing host groups
  uri:
    url: "{{ zabbix_url }}"
    method: POST
    body_format: json
    validate_certs: "{{ zabbix_validate_certs }}"
    body:
      jsonrpc: "2.0"
      method: "hostgroup.create"
      params:
        name: "{{ item }}"
      auth: "{{ zabbix_auth }}"
      id: 102
  loop: "{{ zbx_missing_groups }}"
  register: zbx_created_groups_resp

- name: Refresh host groups map (Fetch all required groups again to get IDs)
  uri:
    url: "{{ zabbix_url }}"
    method: POST
    body_format: json
    validate_certs: "{{ zabbix_validate_certs }}"
    body:
      jsonrpc: "2.0"
      method: "hostgroup.get"
      params:
        output: ["groupid", "name"]
        filter:
          name: "{{ zbx_required_groups }}"
      auth: "{{ zabbix_auth }}"
      id: 103
  register: zbx_final_groups_resp

- name: Build Group Name-to-ID Map
  set_fact:
    zbx_group_map: "{{ zbx_final_groups_resp.json.result | items2dict(key_name='name', value_name='groupid') }}"

- name: Include per-record tasks
  include_tasks: per_record.yml
  loop: "{{ zbx_records }}"
  loop_control:
    loop_var: zbx_record


