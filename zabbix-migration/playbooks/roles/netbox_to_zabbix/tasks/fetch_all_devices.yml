---
- name: Create Python script to fetch all devices with mapping-based filtering
  copy:
    content: |
      #!/usr/bin/env python3
      import json
      import sys
      import requests
      from urllib3.exceptions import InsecureRequestWarning
      
      requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
      
      netbox_url = sys.argv[1].rstrip('/')
      netbox_token = sys.argv[2]
      verify_ssl = sys.argv[3].lower() == 'true'
      mapping_file_path = sys.argv[4]
      location_filter = sys.argv[5] if len(sys.argv) > 5 else ''
      
      # Load device type mapping from file
      with open(mapping_file_path, 'r') as f:
          device_type_mapping = json.load(f)
      mappings = device_type_mapping.get('mappings', [])
      
      # Resolve location ID from location name if filter is provided
      # Also collect child location IDs if the location has children
      location_id_filter = None
      location_ids_to_filter = []
      if location_filter:
          print(f"DEBUG: Resolving location ID for location name: {location_filter}", file=sys.stderr)
          try:
              # Search for location by name
              location_response = requests.get(
                  f"{netbox_url}/api/dcim/locations/",
                  headers={'Authorization': f'Token {netbox_token}', 'Accept': 'application/json'},
                  params={'name': location_filter, 'limit': 1000},
                  verify=verify_ssl,
                  timeout=30
              )
              location_response.raise_for_status()
              location_data = location_response.json()
              locations = location_data.get('results', [])
              
              # Find exact match (case-insensitive)
              matched_location = None
              for loc in locations:
                  if loc.get('name', '').upper() == location_filter.upper():
                      matched_location = loc
                      location_id_filter = loc.get('id')
                      location_ids_to_filter.append(location_id_filter)
                      print(f"DEBUG: Found location ID {location_id_filter} for location name '{location_filter}'", file=sys.stderr)
                      break
              
              if matched_location:
                  # Also fetch child locations (locations that have this location as parent)
                  try:
                      child_locations_response = requests.get(
                          f"{netbox_url}/api/dcim/locations/",
                          headers={'Authorization': f'Token {netbox_token}', 'Accept': 'application/json'},
                          params={'parent_id': location_id_filter, 'limit': 1000},
                          verify=verify_ssl,
                          timeout=30
                      )
                      child_locations_response.raise_for_status()
                      child_locations_data = child_locations_response.json()
                      child_locations = child_locations_data.get('results', [])
                      if child_locations:
                          child_ids = [loc.get('id') for loc in child_locations]
                          location_ids_to_filter.extend(child_ids)
                          print(f"DEBUG: Found {len(child_locations)} child locations. Total location IDs to filter: {len(location_ids_to_filter)}", file=sys.stderr)
                  except Exception as e:
                      print(f"DEBUG: Could not fetch child locations: {e}", file=sys.stderr)
              
              if not location_id_filter:
                  print(f"WARNING: Location '{location_filter}' not found in Netbox. Will fetch all devices.", file=sys.stderr)
          except Exception as e:
              print(f"ERROR: Failed to resolve location ID: {e}", file=sys.stderr)
              print(f"WARNING: Will continue without location filter.", file=sys.stderr)
      
      # Debug: Print mapping info
      print(f"DEBUG: Loaded {len(mappings)} device type mappings", file=sys.stderr)
      
      def device_matches_conditions(device, conditions):
          """Check if device matches the given conditions"""
          # Device role check - Netbox API uses 'role' field, not 'device_role'
          if 'device_role' in conditions:
              # Try 'role' first (Netbox API field name), then 'device_role' as fallback
              role_obj = device.get('role') or device.get('device_role')
              role_name = role_obj.get('name', '') if role_obj and isinstance(role_obj, dict) else ''
              
              # Debug: Print role matching for HOST devices
              expected_roles = conditions['device_role']
              if 'HOST' in role_name.upper() or (isinstance(expected_roles, str) and 'HOST' in expected_roles.upper()) or (isinstance(expected_roles, list) and any('HOST' in str(r).upper() for r in expected_roles)):
                  print(f"DEBUG: Checking HOST device role match: device_role='{role_name}', expected={expected_roles}", file=sys.stderr)
              
              if isinstance(expected_roles, list):
                  if not role_name or role_name.upper() not in [r.upper() for r in expected_roles]:
                      if 'HOST' in role_name.upper():
                          print(f"DEBUG: HOST device role '{role_name}' does not match expected roles {expected_roles}", file=sys.stderr)
                      return False
              else:
                  if not role_name or role_name.upper() != expected_roles.upper():
                      if 'HOST' in role_name.upper():
                          print(f"DEBUG: HOST device role '{role_name}' does not match expected role '{expected_roles}'", file=sys.stderr)
                      return False
          
          # Manufacturer check
          if 'manufacturer' in conditions:
              manufacturer_name = device.get('device_type', {}).get('manufacturer', {}).get('name', '') if device.get('device_type', {}).get('manufacturer') else ''
              expected_manufacturers = conditions['manufacturer']
              if isinstance(expected_manufacturers, list):
                  if not manufacturer_name or manufacturer_name.upper() not in [m.upper() for m in expected_manufacturers]:
                      return False
              else:
                  if not manufacturer_name or manufacturer_name.upper() != expected_manufacturers.upper():
                      return False
          
          # Model contains check
          if 'model_contains' in conditions:
              model = device.get('device_type', {}).get('model', '') if device.get('device_type') else ''
              expected_contains = conditions['model_contains']
              if isinstance(expected_contains, list):
                  if not any(contain.upper() in model.upper() for contain in expected_contains):
                      return False
              else:
                  if expected_contains.upper() not in model.upper():
                      return False
          
          # Model suffix check
          if 'model_suffix' in conditions:
              model = device.get('device_type', {}).get('model', '') if device.get('device_type') else ''
              expected_suffix = conditions['model_suffix']
              if not model.upper().endswith(expected_suffix.upper()):
                  return False
          
          # Name contains check
          if 'name_contains' in conditions:
              name = device.get('name', '')
              expected_contains = conditions['name_contains']
              if isinstance(expected_contains, list):
                  if not any(contain.upper() in name.upper() for contain in expected_contains):
                      return False
              else:
                  if expected_contains.upper() not in name.upper():
                      return False
          
          return True
      
      def device_matches_any_mapping(device):
          """Check if device matches any mapping condition"""
          for mapping in mappings:
              conditions = mapping.get('conditions', {})
              if device_matches_conditions(device, conditions):
                  return True
          return False
      
      all_devices = []
      # Build API URL with location filter if location ID was resolved
      # If multiple location IDs (parent + children), we'll need to fetch separately or use a different approach
      api_url = f"{netbox_url}/api/dcim/devices/?limit=1000"
      if location_ids_to_filter:
          # Netbox API supports filtering by multiple location IDs using location_id parameter multiple times
          # But we'll use a simpler approach: fetch for each location ID and combine
          if len(location_ids_to_filter) == 1:
              api_url += f"&location_id={location_ids_to_filter[0]}"
              print(f"DEBUG: Applying location filter at API level: location_id={location_ids_to_filter[0]}", file=sys.stderr)
          else:
              # For multiple locations, we'll fetch all and filter in Python
              print(f"DEBUG: Multiple location IDs found ({len(location_ids_to_filter)}). Will fetch all devices and filter by location in Python.", file=sys.stderr)
              api_url = f"{netbox_url}/api/dcim/devices/?limit=1000"
      
      next_url = api_url
      
      while next_url:
          try:
              response = requests.get(
                  next_url,
                  headers={
                      'Authorization': f'Token {netbox_token}',
                      'Accept': 'application/json'
                  },
                  verify=verify_ssl,
                  timeout=30
              )
              response.raise_for_status()
              data = response.json()
              
              devices = data.get('results', [])
              
              # Debug: Print page info
              print(f"DEBUG: Fetched {len(devices)} devices from this page", file=sys.stderr)
              
              # Debug: Print role distribution
              if len(devices) > 0:
                  role_count = {}
                  for device in devices:
                      role_obj = device.get('role') or device.get('device_role')
                      role_name = role_obj.get('name', 'Unknown') if role_obj and isinstance(role_obj, dict) else 'Unknown'
                      role_count[role_name] = role_count.get(role_name, 0) + 1
                  print(f"DEBUG: Role distribution on this page: {role_count}", file=sys.stderr)
              
              # Debug: Print all devices with HOST role (before filtering)
              host_devices = []
              for device in devices:
                  role_obj = device.get('role') or device.get('device_role')
                  role_name = role_obj.get('name', '') if role_obj and isinstance(role_obj, dict) else ''
                  if role_name and 'HOST' in role_name.upper():
                      host_devices.append(device)
              
              if host_devices:
                  print(f"DEBUG: Found {len(host_devices)} HOST devices on this page (before mapping filters):", file=sys.stderr)
                  for i, device in enumerate(host_devices[:10]):  # Show first 10 HOST devices
                      role_obj = device.get('role') or device.get('device_role')
                      role_name = role_obj.get('name', 'N/A') if role_obj and isinstance(role_obj, dict) else 'N/A'
                      manufacturer_name = device.get('device_type', {}).get('manufacturer', {}).get('name', 'N/A') if device.get('device_type', {}).get('manufacturer') else 'N/A'
                      model = device.get('device_type', {}).get('model', 'N/A') if device.get('device_type') else 'N/A'
                      name = device.get('name', 'N/A')
                      device_location = 'N/A'
                      if device.get('location'):
                          if isinstance(device.get('location'), dict):
                              device_location = device.get('location', {}).get('name', 'N/A')
                          elif isinstance(device.get('location'), int):
                              device_location = f"ID:{device.get('location')}"
                      elif device.get('site'):
                          if isinstance(device.get('site'), dict):
                              device_location = device.get('site', {}).get('name', 'N/A')
                      print(f"  HOST Device {i+1}: name={name}, location={device_location}, role={role_name}, manufacturer={manufacturer_name}, model={model}", file=sys.stderr)
              else:
                  print("DEBUG: No HOST devices found on this page", file=sys.stderr)
              
              # Debug: Print sample device details (first 3 devices)
              if len(devices) > 0 and len(all_devices) == 0:  # Only print on first page
                  print("DEBUG: Sample device details (first 3 devices):", file=sys.stderr)
                  for i, device in enumerate(devices[:3]):
                      # Try 'role' first (Netbox API field name), then 'device_role' as fallback
                      role_obj = device.get('role') or device.get('device_role')
                      role_name = role_obj.get('name', 'N/A') if role_obj and isinstance(role_obj, dict) else 'N/A'
                      manufacturer_name = device.get('device_type', {}).get('manufacturer', {}).get('name', 'N/A') if device.get('device_type', {}).get('manufacturer') else 'N/A'
                      model = device.get('device_type', {}).get('model', 'N/A') if device.get('device_type') else 'N/A'
                      name = device.get('name', 'N/A')
                      # Get location info
                      device_location = 'N/A'
                      if device.get('location'):
                          if isinstance(device.get('location'), dict):
                              device_location = device.get('location', {}).get('name', 'N/A')
                          elif isinstance(device.get('location'), int):
                              device_location = f"ID:{device.get('location')}"
                      elif device.get('site'):
                          if isinstance(device.get('site'), dict):
                              device_location = device.get('site', {}).get('name', 'N/A')
                      print(f"  Device {i+1}: name={name}, location={device_location}, role={role_name}, manufacturer={manufacturer_name}, model={model}", file=sys.stderr)
              
              # Apply mapping-based filters (location filter already applied at API level)
              filtered_devices = []
              unmatched_count = 0
              for device in devices:
                  # Check mapping-based filters
                  if device_matches_any_mapping(device):
                      filtered_devices.append(device)
                  else:
                      unmatched_count += 1
                      # Debug: Print first unmatched device details for troubleshooting
                      if unmatched_count == 1 and len(all_devices) == 0:
                          # Try 'role' first (Netbox API field name), then 'device_role' as fallback
                          role_obj = device.get('role') or device.get('device_role')
                          role_name = role_obj.get('name', 'N/A') if role_obj and isinstance(role_obj, dict) else 'N/A'
                          manufacturer_name = device.get('device_type', {}).get('manufacturer', {}).get('name', 'N/A') if device.get('device_type', {}).get('manufacturer') else 'N/A'
                          model = device.get('device_type', {}).get('model', 'N/A') if device.get('device_type') else 'N/A'
                          name = device.get('name', 'N/A')
                          print(f"DEBUG: First unmatched device: name={name}, role={role_name}, manufacturer={manufacturer_name}, model={model}", file=sys.stderr)
                          # Check why it doesn't match
                          for mapping in mappings:
                              conditions = mapping.get('conditions', {})
                              print(f"  Checking mapping '{mapping.get('device_type', 'N/A')}':", file=sys.stderr)
                              if 'device_role' in conditions:
                                  expected_role = conditions['device_role']
                                  if isinstance(expected_role, list):
                                      print(f"    device_role: expected one of {expected_role}, got '{role_name}'", file=sys.stderr)
                                  else:
                                      print(f"    device_role: expected '{expected_role}', got '{role_name}'", file=sys.stderr)
                              if 'manufacturer' in conditions:
                                  expected_manufacturer = conditions['manufacturer']
                                  if isinstance(expected_manufacturer, list):
                                      print(f"    manufacturer: expected one of {expected_manufacturer}, got '{manufacturer_name}'", file=sys.stderr)
                                  else:
                                      print(f"    manufacturer: expected '{expected_manufacturer}', got '{manufacturer_name}'", file=sys.stderr)
                              if 'model_contains' in conditions:
                                  expected_contains = conditions['model_contains']
                                  print(f"    model_contains: expected {expected_contains}, got model '{model}'", file=sys.stderr)
                              if 'model_suffix' in conditions:
                                  expected_suffix = conditions['model_suffix']
                                  print(f"    model_suffix: expected '{expected_suffix}', got model '{model}'", file=sys.stderr)
                          break
              
              all_devices.extend(filtered_devices)
              filter_info = "mapping filters"
              if location_ids_to_filter:
                  if len(location_ids_to_filter) == 1:
                      filter_info += f" + location filter (ID: {location_ids_to_filter[0]})"
                  else:
                      filter_info += f" + location filter (IDs: {location_ids_to_filter})"
                      if location_filtered_count > 0:
                          print(f"DEBUG: Location filter stats: {location_filtered_count} devices filtered out by location on this page", file=sys.stderr)
              print(f"DEBUG: After {filter_info}, {len(filtered_devices)} devices match on this page", file=sys.stderr)
              next_url = data.get('next')
              
              if not next_url:
                  break
          except Exception as e:
              print(f"Error: {e}", file=sys.stderr)
              sys.exit(1)
      
      # Debug: Print final results
      filter_info = "mapping filters"
      if location_id_filter:
          filter_info += f" + location filter (ID: {location_id_filter}, name: {location_filter})"
      print(f"DEBUG: Total devices after {filter_info}: {len(all_devices)}", file=sys.stderr)
      
      result = {
          'devices': all_devices,
          'count': len(all_devices)
      }
      
      print(json.dumps(result))
    dest: "/tmp/fetch_all_netbox_devices.py"
    mode: '0755'
  delegate_to: localhost
  run_once: true

- name: Save device type mapping to temporary file
  copy:
    content: "{{ device_type_mapping | to_json }}"
    dest: "/tmp/netbox_device_type_mapping.json"
  delegate_to: localhost
  run_once: true

- name: Display mapping-based filtering info
  debug:
    msg: |
      ============================================
      MAPPING-BASED FILTERING
      ============================================
      Using device type mapping file: {{ device_type_mapping_path }}
      Total mappings loaded: {{ device_type_mapping.mappings | length }}
      Mappings:
      {% for mapping in device_type_mapping.mappings %}
      - {{ mapping.device_type }}: {{ mapping.conditions | to_nice_json }}
      {% endfor %}
      ============================================

- name: Fetch all devices using Python script with mapping-based filtering
  command: >
    python3 /tmp/fetch_all_netbox_devices.py
    "{{ netbox_url }}"
    "{{ netbox_token }}"
    "{{ netbox_verify_ssl | string }}"
    "/tmp/netbox_device_type_mapping.json"
    "{{ location_filter | default('') }}"
  register: fetch_devices_result
  changed_when: false
  delegate_to: localhost

- name: Display Python script debug output
  debug:
    msg: "{{ fetch_devices_result.stderr_lines | default([]) | join('\n') }}"
  when: fetch_devices_result.stderr_lines is defined and fetch_devices_result.stderr_lines | length > 0

- name: Parse fetched devices
  set_fact:
    netbox_devices_raw: "{{ (fetch_devices_result.stdout | from_json).devices }}"
    netbox_devices_count: "{{ (fetch_devices_result.stdout | from_json).count }}"

- name: Display fetch results
  debug:
    msg: |
      ============================================
      NETBOX API FETCH RESULTS
      ============================================
      Total devices found after filters: {{ netbox_devices_count }}
      Raw devices list length: {{ netbox_devices_raw | length }}
      ============================================

